// ==UserScript==
// @name         Google AI Studio Model Injector
// @namespace    http://tampermonkey.net/
// @version      1.6.5
// @description  Inject custom models into Google AI Studio with theme emoji icons. Intercepts XHR/Fetch requests, processes array-structured JSON data
// @author       Generated by AI / HCPTangHY / Mozi / wisdgod / UserModified
// @match        https://aistudio.google.com/*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=aistudio.google.com
// @grant        none
// @run-at       document-start
// @license      MIT
// ==/UserScript==

(function() {
    'use strict';

    // ==================== CONFIGURATION ====================
    // Script is no longer active

    const SCRIPT_VERSION = "none";
    const LOG_PREFIX = `[AI Studio Injector ${SCRIPT_VERSION}]`;
    const ANTI_HIJACK_PREFIX = ")]}'\n";

    // Model configuration list
    // Ordered as requested with jfdksal98a below blacktooth
    const MODELS_TO_INJECT = [

        // All models below are deprecated, kept for reference
        // { name: 'models/gemini-2.5-pro-preview-03-25', displayName: `âœ¨ Gemini 2.5 Pro 03-25 (Script ${SCRIPT_VERSION})`, description: `Model injected by script ${SCRIPT_VERSION}` },
        // { name: 'models/gemini-2.5-pro-exp-03-25', displayName: `âœ¨ Gemini 2.5 Pro 03-25 (Script ${SCRIPT_VERSION})`, description: `Model injected by script ${SCRIPT_VERSION}` },
        // { name: 'models/gemini-2.5-pro-preview-06-05', displayName: `âœ¨ Gemini 2.5 Pro 03-25 (Script ${SCRIPT_VERSION})`, description: `Model injected by script ${SCRIPT_VERSION}` },
        // { name: 'models/blacktooth-ab-test', displayName: `ðŸ´â€â˜ ï¸ Blacktooth (Script ${SCRIPT_VERSION})`, description: `Model injected by script ${SCRIPT_VERSION}` },
        // { name: 'models/jfdksal98a', displayName: `ðŸª jfdksal98a (Script ${SCRIPT_VERSION})`, description: `Model injected by script ${SCRIPT_VERSION}` },
        // { name: 'models/gemini-2.5-pro-preview-03-25', displayName: `âœ¨ Gemini 2.5 Pro 03-25 (Script ${SCRIPT_VERSION})`, description: `Model injected by script ${SCRIPT_VERSION}` },
        // { name: 'models/goldmane-ab-test', displayName: `ðŸ¦ Goldmane (Script ${SCRIPT_VERSION})`, description: `Model injected by script ${SCRIPT_VERSION}` },
        // { name: 'models/claybrook-ab-test', displayName: `ðŸ’§ Claybrook (Script ${SCRIPT_VERSION})`, description: `Model injected by script ${SCRIPT_VERSION}` },
        // { name: 'models/frostwind-ab-test', displayName: `â„ï¸ Frostwind (Script ${SCRIPT_VERSION})`, description: `Model injected by script ${SCRIPT_VERSION}` },
        // { name: 'models/calmriver-ab-test', displayName: `ðŸŒŠ Calmriver (Script ${SCRIPT_VERSION})`, description: `Model injected by script ${SCRIPT_VERSION}` }
    ];

    // Field indices in JSON structure
    const MODEL_FIELDS = {
        NAME: 0,
        DISPLAY_NAME: 3,
        DESCRIPTION: 4,
        METHODS: 7
    };

    // ==================== UTILITY FUNCTIONS ====================

    /**
     * Check if URL is the target API endpoint
     * @param {string} url - URL to check
     * @returns {boolean}
     */
    function isTargetURL(url) {
        return url && typeof url === 'string' &&
               url.includes('alkalimakersuite') &&
               url.includes('/ListModels');
    }

    /**
     * Recursively find model list array
     * @param {any} obj - Object to search
     * @returns {Array|null} Found model array or null
     */
    function findModelListArray(obj) {
        if (!obj) return null;

        // Check if this is the target model array
        if (Array.isArray(obj) && obj.length > 0 && obj.every(
            item => Array.isArray(item) &&
                    typeof item[MODEL_FIELDS.NAME] === 'string' &&
                    String(item[MODEL_FIELDS.NAME]).startsWith('models/')
        )) {
            return obj;
        }

        // Recursively search child objects
        if (typeof obj === 'object') {
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key) &&
                    typeof obj[key] === 'object' &&
                    obj[key] !== null) {
                    const result = findModelListArray(obj[key]);
                    if (result) return result;
                }
            }
        }
        return null;
    }

    /**
     * Find a suitable template model
     * @param {Array} modelsArray - Model array
     * @returns {Array|null} Template model or null
     */
    function findTemplateModel(modelsArray) {
        // Prioritize finding models containing specific keywords
        const templateModel =
            modelsArray.find(m => Array.isArray(m) &&
                                 m[MODEL_FIELDS.NAME] &&
                                 String(m[MODEL_FIELDS.NAME]).includes('pro') &&
                                 Array.isArray(m[MODEL_FIELDS.METHODS])) ||
            modelsArray.find(m => Array.isArray(m) &&
                                 m[MODEL_FIELDS.NAME] &&
                                 String(m[MODEL_FIELDS.NAME]).includes('flash') &&
                                 Array.isArray(m[MODEL_FIELDS.METHODS])) ||
            modelsArray.find(m => Array.isArray(m) &&
                                 m[MODEL_FIELDS.NAME] &&
                                 Array.isArray(m[MODEL_FIELDS.METHODS]));

        return templateModel;
    }

    /**
     * Update display name of existing model
     * @param {Array} existingModel - Existing model
     * @param {Object} modelToInject - Model configuration to inject
     * @returns {boolean} Whether update was performed
     */
    function updateExistingModel(existingModel, modelToInject) {
        if (!existingModel || existingModel[MODEL_FIELDS.DISPLAY_NAME] === modelToInject.displayName) {
            return false;
        }

        // Extract base name (remove version number and emoji)
        // Updated regex to match vX.Y.Z format
        const cleanName = (name) => String(name)
            .replace(/ \(Script v\d+\.\d+(\.\d+)?(-beta\d*)?\)/, '')
            // Includes all currently used emojis, including new ðŸ´â€â˜ ï¸, ðŸ¤–, ðŸª
            .replace(/^[âœ¨ðŸ¦ðŸ’§â„ï¸ðŸŒŠðŸ‰ðŸ´â€â˜ ï¸ðŸ¤–ðŸª]\s*/, '')
            .trim();

        const baseExistingName = cleanName(existingModel[MODEL_FIELDS.DISPLAY_NAME]);
        const baseInjectName = cleanName(modelToInject.displayName);

        if (baseExistingName === baseInjectName) {
            // Only update version number and emoji
            existingModel[MODEL_FIELDS.DISPLAY_NAME] = modelToInject.displayName;
            console.log(LOG_PREFIX, `Updated emoji/version: ${modelToInject.displayName}`);
        } else {
            // Mark as original model
            existingModel[MODEL_FIELDS.DISPLAY_NAME] = modelToInject.displayName + " (Original)";
            console.log(LOG_PREFIX, `Updated display name of official model ${modelToInject.name}`);
        }
        return true;
    }

    /**
     * Create new model
     * @param {Array} templateModel - Template model
     * @param {Object} modelToInject - Model configuration to inject
     * @param {string} templateName - Template name
     * @returns {Array} New model array
     */
    function createNewModel(templateModel, modelToInject, templateName) {
        const newModel = structuredClone(templateModel);

        newModel[MODEL_FIELDS.NAME] = modelToInject.name;
        newModel[MODEL_FIELDS.DISPLAY_NAME] = modelToInject.displayName;
        newModel[MODEL_FIELDS.DESCRIPTION] = `${modelToInject.description} (Based on ${templateName} structure)`;

        if (!Array.isArray(newModel[MODEL_FIELDS.METHODS])) {
            newModel[MODEL_FIELDS.METHODS] = [
                "generateContent",
                "countTokens",
                "createCachedContent",
                "batchGenerateContent"
            ];
        }

        return newModel;
    }

    // ==================== CORE PROCESSING FUNCTIONS ====================

    /**
     * Process and modify JSON data
     * @param {Object} jsonData - Original JSON data
     * @param {string} url - Request URL
     * @returns {Object} Object containing processed data and modification flag
     */
    function processJsonData(jsonData, url) {
        let modificationMade = false;
        const modelsArray = findModelListArray(jsonData);

        if (!modelsArray || !Array.isArray(modelsArray)) {
            console.warn(LOG_PREFIX, 'No valid model list structure found in JSON:', url);
            return { data: jsonData, modified: false };
        }

        // Find template model
        const templateModel = findTemplateModel(modelsArray);
        const templateName = templateModel?.[MODEL_FIELDS.NAME] || 'unknown';

        if (!templateModel) {
            console.warn(LOG_PREFIX, 'No suitable template model found, cannot inject new models');
        }

        // Reverse iterate to maintain display order (models at top of config appear first)
        [...MODELS_TO_INJECT].reverse().forEach(modelToInject => {
            const existingModel = modelsArray.find(
                model => Array.isArray(model) && model[MODEL_FIELDS.NAME] === modelToInject.name
            );

            if (!existingModel) {
                // Inject new model
                if (!templateModel) {
                    console.warn(LOG_PREFIX, `Cannot inject ${modelToInject.name}: missing template`);
                    return;
                }

                const newModel = createNewModel(templateModel, modelToInject, templateName);
                modelsArray.unshift(newModel); // unshift adds model to beginning of array
                modificationMade = true;
                console.log(LOG_PREFIX, `Successfully injected: ${modelToInject.displayName}`);
            } else {
                // Update existing model
                if (updateExistingModel(existingModel, modelToInject)) {
                    modificationMade = true;
                }
            }
        });

        return { data: jsonData, modified: modificationMade };
    }

    /**
     * Modify response body
     * @param {string} originalText - Original response text
     * @param {string} url - Request URL
     * @returns {string} Modified response text
     */
    function modifyResponseBody(originalText, url) {
        if (!originalText || typeof originalText !== 'string') {
            return originalText;
        }

        try {
            let textBody = originalText;
            let hasPrefix = false;

            // Handle anti-hijack prefix
            if (textBody.startsWith(ANTI_HIJACK_PREFIX)) {
                textBody = textBody.substring(ANTI_HIJACK_PREFIX.length);
                hasPrefix = true;
            }

            if (!textBody.trim()) return originalText;

            const jsonData = JSON.parse(textBody);
            const result = processJsonData(jsonData, url);

            if (result.modified) {
                let newBody = JSON.stringify(result.data);
                if (hasPrefix) {
                    newBody = ANTI_HIJACK_PREFIX + newBody;
                }
                return newBody;
            }
        } catch (error) {
            console.error(LOG_PREFIX, 'Error processing response body:', url, error);
        }

        return originalText;
    }

    // ==================== REQUEST INTERCEPTION ====================

    // Intercept Fetch API
    const originalFetch = window.fetch;
    window.fetch = async function(...args) {
        const resource = args[0];
        const url = (resource instanceof Request) ? resource.url : String(resource);
        const response = await originalFetch.apply(this, args);

        if (isTargetURL(url) && response.ok) {
            console.log(LOG_PREFIX, '[Fetch] Intercepted target request:', url);
            try {
                const cloneResponse = response.clone();
                const originalText = await cloneResponse.text();
                const newBody = modifyResponseBody(originalText, url);

                if (newBody !== originalText) {
                    return new Response(newBody, {
                        status: response.status,
                        statusText: response.statusText,
                        headers: response.headers
                    });
                }
            } catch (e) {
                console.error(LOG_PREFIX, '[Fetch] Processing error:', e);
            }
        }
        return response;
    };

    // Intercept XMLHttpRequest
    const xhrProto = XMLHttpRequest.prototype;
    const originalOpen = xhrProto.open;
    const originalResponseTextDescriptor = Object.getOwnPropertyDescriptor(xhrProto, 'responseText');
    const originalResponseDescriptor = Object.getOwnPropertyDescriptor(xhrProto, 'response');
    let interceptionCount = 0;

    // Override open method
    xhrProto.open = function(method, url) {
        this._interceptorUrl = url;
        this._isTargetXHR = isTargetURL(url);

        if (this._isTargetXHR) {
            interceptionCount++;
            console.log(LOG_PREFIX, `[XHR] Detected target request (${interceptionCount}):`, url);
        }

        return originalOpen.apply(this, arguments);
    };

    /**
     * Handle XHR response
     * @param {XMLHttpRequest} xhr - XHR object
     * @param {any} originalValue - Original response value
     * @param {string} type - Response type
     * @returns {any} Processed response value
     */
    const handleXHRResponse = (xhr, originalValue, type = 'text') => {
        if (!xhr._isTargetXHR || xhr.readyState !== 4 || xhr.status !== 200) {
            return originalValue;
        }

        const cacheKey = '_modifiedResponseCache_' + type;

        if (xhr[cacheKey] === undefined) {
            const originalText = (type === 'text' || typeof originalValue !== 'object' || originalValue === null)
                ? String(originalValue || '')
                : JSON.stringify(originalValue);

            xhr[cacheKey] = modifyResponseBody(originalText, xhr._interceptorUrl);
        }

        const cachedResponse = xhr[cacheKey];

        try {
            if (type === 'json' && typeof cachedResponse === 'string') {
                const textToParse = cachedResponse.replace(ANTI_HIJACK_PREFIX, '');
                return textToParse ? JSON.parse(textToParse) : null;
            }
        } catch (e) {
            console.error(LOG_PREFIX, '[XHR] Error parsing cached JSON:', e);
            return originalValue;
        }

        return cachedResponse;
    };

    // Override responseText property
    if (originalResponseTextDescriptor?.get) {
        Object.defineProperty(xhrProto, 'responseText', {
            get: function() {
                const originalText = originalResponseTextDescriptor.get.call(this);

                if (this.responseType && this.responseType !== 'text' && this.responseType !== "") {
                    return originalText;
                }

                return handleXHRResponse(this, originalText, 'text');
            },
            configurable: true
        });
    }

    // Override response property
    if (originalResponseDescriptor?.get) {
        Object.defineProperty(xhrProto, 'response', {
            get: function() {
                const originalResponse = originalResponseDescriptor.get.call(this);

                if (this.responseType === 'json') {
                    return handleXHRResponse(this, originalResponse, 'json');
                }

                if (!this.responseType || this.responseType === 'text' || this.responseType === "") {
                    return handleXHRResponse(this, originalResponse, 'text');
                }

                return originalResponse;
            },
            configurable: true
        });
    }

    console.log(LOG_PREFIX, 'Script activated, Fetch and XHR interception enabled');
})();
